<!DOCTYPE html>
<html>
<head>
	<title>Cross-Site Scripting Vulnerability (Mobile)</title>
	<link rel="stylesheet" href="../style.css">
</head>
<body>
	<div class="wrapper">
		<h1>Cross-Site Scripting Vulnerability (Mobile)</h1>
		<div class="navlinks">
			<ul class="horizontal">
				<li><a href="../index.html">Home</a></li>
				<li><a href="3.9.1_cross_site_mechanisms.html">Cross Site Mechanisms</a></li>
				<li><a href="3.9.1_cross_site_scripting_solution.html">Solution</a></li>
			</ul>
		</div>

		<h2 id="introduction">Introduction</h2>
		<p>
			In Android, WebView is the component that allows applications to display and interact with online resources. It is provided by the <code>android.webkit</code> package, which also contains several other useful classes such as WebChromeClient and CookieManager. In this exercise, we will discuss Cross-Site Scripting attacks to Android WebView.
		</p>

		<p>
			Cross-Site Scripting vulnerabilities allow an attacker to execute browser scripts on a victim's machine. The attack is delivered through a benign or trusted web site that contains this vulnerability. In a successful attack, the victim's browser will load the attacking script and execute it.
		</p>
		<p>
			Most Cross-Site Scripting attacks fall into two categories: stored or reflected. Stored Cross-Site Scripting attacks have some persistence over time and separate visits. For example, if a script is injected into a public-facing comment, then any user who visits the page containing that comment will be affected. In the case of reflected Cross-Site Scripting, the attack originates in a malicious link or web site and is "reflected" off the vulnerable site. For example, if a web site shows an error message whose content is taken from an HTTP request parameter, then an attacker can craft a link where the parameter contains a malicious script; this malicious script is then present on the loaded web page.
		</p>
		<h3 id="description">Exercise Description</h3>
		<p>
			In this exercise we provide an Android application on the virtual machine which presents a web page with XSS vulnerability. The web page is generated by a small HTTP server, which prompts visitors for a username and counts the number of times that user clicks a specific link. Once registered, the web site will display the current user's username, the number of times that user has clicked the link, and the link to be clicked. This naive server does not have any form of authentication and does not persistently store the click count. For the purposes of this exercise, we will not consider the implications of these traits. Instead, we will focus on the potential for reflected Cross-Site Scripting. Your objective is to create a link that will direct a victim to the vulnerable site and execute a "malicious" script.
		</p>

		<p>
			The program has five source files and one Android project folder: <code>TargetServer.java</code>, <code>DoActionServlet.java</code>, <code>LoginServlet.java</code>, <code>ViewPageServlet.java</code> and <code>XSSAttack</code>. The servlets are each attached to a URL path on the server, so all requests directed to that path will be handled by that servlet's implementation. The following table summarizes each file's purpose.
		</p>

		<table style="width: 100%" border="1">
			<tr>
				<th>Filename</th>
				<th>URL Path</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><code>TargetServer.java</code></td>
				<td>n/a</td>
				<td>Initializes and starts the vulnerable web server. <b>You will not need to change this file.</b></td>
			</tr>
			<tr>
				<td><code>DoActionServlet.java</code></td>
				<td>localhost:8080/action</td>
				<td>Each request to this servlet increments a counter stored with the session that is attached to the request; if no session exists, nothing happens. Requests to this servlet are logged to stdout in the server command line interface. <b>You will not need to change this file</b> until the Cross Site Request Forgery exercise.</td>
			</tr>
			<tr>
				<td><code>LoginServlet.java</code></td>
				<td>localhost:8080/login</td>
				<td>Requests to this servlet will create a new session based on a username parameter. If a session already exists, it resets the counter for that session. <b>You may change this file</b> in part of the mitigation for this exercise.</td>
			</tr>
			<tr>
				<td><code>ViewPageServlet.java</code></td>
				<td>localhost:8080/</td>
				<td>This servlet displays one of two html pages based on the presence of a session. If there is a session, it shows a link and a counter for how many times the current session has clicked the link. If there is no session, it shows a form for creating a session. <b>You will need to change this file</b> in part of the mitigation for this exercise.</td>
			</tr>
			<tr>
				<td><code>XSSAttack</code></td>
				<td>n/a</td>
				<td>This is the Android project that you need to import into Android Studio and run on a AVD <b>You will not need to change this folder.</b></td>
			</tr>
		</table>

		<h3 id="mitigation_description">Vulnerability Mitigation</h3>
		<p>
			Mitigating a cross site scripting vulnerability can be a complicated and challenging task. A trivial solution is to simply never display user-supplied content on a website, but that is unacceptable for any kind of interactive web experience. The challenge then becomes a matter of restricting, encoding, escaping, and validating any input that must be interpreted by a web browser. For a nearly comprehensive approach to cross site scripting mitigation, see the <a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">OWASP Cross Site Scripting Prevention Cheat Sheet</a>.
		</p>
		<p>
			For the cross site scripting vulnerability present in this exercise, there are many ways to prevent the attack. We will focus on a whitelisting approach. Your objective is to create a whitelist filter that effectively disrupts the attack vector while preserving the functionality of the web site.
		</p>

		<h2 id="instructions">Exercise Instructions</h2>
		<p>
			This exercise will be completed with the help of Android Studio(version 3.2.1) and Command Prompt in Windows.
		</p>
		<h3>
			<b>First you need to run the web server in Windows</b>
		</h3>
		<ol>

			<li>
				<b>Download XSSAttack(mobile).zip from ~cs637/Exercise/....  to your local host.</b>

				<p>
					Unzip the package to see an android project folder named <code>XSSAttack</code> and several other files listed in the table above. 
				</p>
			</li>


			<li>
				<p>
					<b>Open Command Prompt in Windows</b>
				</p>
				<p>
					To open the Command Prompt, click <b>Windows</b> and type <b>cmd</b> in the search box and choose the result on the top.
				</p>
			</li>

			<li>
				<p>
					<b>Run the server</b>
				</p>
				<ol type="a">
					<li>
						<p>
							In the Command Prompt, <code>cd</code> into the directory containing the unzipped files
						</p>
					</li>


					<li>
						<p>
							Every time you change the a .java file, you must recompile the program before running it again. Enter the following command to compile the program:
						</p>
						<pre><code>javac -Djava.ext.dirs=./lib *.java</code></pre>
					</li>


					<li>
						<p>
							This program depends on files in the lib directory, so the command to run the server in Windows is:
						</p>
						<pre><code>java -Djava.ext.dirs=./lib TargetServer</code></pre>
					</li>


					<li>
						<p>
							To stop the server, type <code>quit</code> in the command line interface and press enter. 
						</p>
					</li>


				</ol>
			</li>	
		</ol>








		<h3>
			<b>Then you need to run the Android Project from Android Studio</b>
		</h3>


		<ol> 			
			<li>
				<p>
					<b>Download and install <a href = "https://developer.android.com/studio/">Android Studio(3.2.1)</a></b>
				</p>
			</li>


			<li>
				<p>
					<b>Open the Android Studio and click "File" -> "open" -> "XSSAttack" to load the project</b>
				</p>
				<p>
					To create an AVD(Android Virtual Device) for your Android Studio, see the instruction <a href=https://developer.android.com/studio/run/managing-avds>here</a>.  
				</p>
			</li>
			<li>
				<p>
					<b>Run the project</b>
				</p>
				<p>
					Click the <b>Run</b> button in the Android Studio and choose the AVD you just created as the deployment target.
				</p>
				<p>
					The first page you see is the html welcome page. You can enter a user name and click <b>Submit</b> to create a session. This will take you to a different page. Take note of the elements on this page. When you click on the <b>CLICK</b> link, it will increment your session's counter and refresh the page. 
				</p>
				<p>
					Try logging into the server and clicking the link. Note that the server command line will log the click and the counter updates. Experiment with the interface until you understand the basic behavior of the program and how the various pieces interact. 
				</p>
			</li> 	
		</ol>
		<h2 id="inspect" class="steps">Inspect the Program Code</h2>
		<p>
			Now that you understand the basic behavior of the program, it's time to look at the implementation. As mentioned above, this program is implemented in four files. Focus on the <code>ViewPageServlet.java</code> and <code>LoginServlet.java</code> files first. Use your favorite <a href="../text_editors.html">text editor</a> to open these files. Enter the following command to open each file in Nano:
		</p>

		<pre><code>$ nano ViewPageServlet.java
		$ nano LoginServlet.java</code></pre>

		<p>
			Spend some time looking at the code alongside the above diagram and follow the flow of data through the servlets. Where does a user's input enter the system? How is this input stored and eventually displayed on a page? Can this user input come from a malicious link?
		</p>

		<p>
			In <code>ViewPageServlet.java</code>, you should notice the following code section:
		</p>

		<pre><code>// session exists, show button clicker
			String username = (String) session.getAttribute("username");
			Integer clickCount = (Integer) session.getAttribute("clicks");

			content.print("&lt;h1&gt;");
			content.print("Welcome, ");
			content.print(username);
			content.print("!");
		content.println("&lt;/h1&gt;");</code></pre>

		<p>
			In <code>LoginServlet.java</code>, you should notice this code section:
		</p>

		<pre><code>// check for username parameter
			String username = req.getParameter("username");
			if (username != null && !username.equals("")) {
			// request contained a username, set session attribute for username and
			// initialize click count to zero
			req.getSession(true).setAttribute("username", username);
			req.getSession().setAttribute("clicks", new Integer(0));
		}</code></pre>

		<h2 id="exploit" class="steps">Exploit the Vulnerability</h2>
		<p>
			Start thinking of how user input flows through the application to eventually reach a rendered web page. This is the key component of a cross site scripting attack. Your goal is to craft a link that will, when clicked by a victim, execute a script in the victim's browser. In a real attack, this script could be anything from a simple exfiltration script to a powerful malware installation script. For now, we'll keep it to a simple popup window. The string <code>&lt;script&gt;window.alert(&#33.hacked&#33.);&lt;/script&gt;</code> will create a popup that says "hacked" when a browser renders it in normal HTML. This serves as a non-destructive and easy way to check if your cross site scripting exploit was successful. The question now is: "How can we get that string into our victim's web page?" Try to think of some potential attack vectors and test them out with that string. Come back when you are stuck or successful.
		</p>

		<p>
			If you're stuck, a good place to start is the login form and welcome message. Where does the username string come from? See if putting your attack string into the username form does anything interesting.
		</p>

		<p>
			By now you should see that the Cross-Site Scripting attack are not only exist on webpages viewing from your laptops or desktops, but also on applications on your mobile devices which use WebView or similar components to show websites. In fact, Cross-Site Scripting is a type of computer security vulnerability typically found in web applications. With nowadays more and more mobile applications using web applications to extend their functionality, we cannot ignore the potential risks brought by XSS attack.
		</p>


		<h2 id="mitigate" class="steps">Mitigate the Vulnerability</h2>
		<p>
			As mentioned in the introduction, mitigating cross site scripting vulnerabilities takes careful consideration. For this exercise, we will focus on a simple but restrictive mitigation technique: whitelisting. A whitelist is a filter that only allows approved content. This is simple because you can easily come up with a set of "safe" inputs, but it is restrictive because you will inherently disallow many safe inputs that are not included in your list. Again, see the <a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">OWASP Cross Site Scripting Prevention Cheat Sheet</a> for more advanced techniques. 
		</p>

		<p>
			Your first mitigation task is to decide what characters can be considered "safe" for rendering in the web browser. An easy answer is to allow only alphanumeric characters, hyphens, and underscores. None of those characters can be construed into a script tag, and they allow at least some reasonable freedom for a username field. However, this would not be sufficient for an international web site. For example, users who speak languages with characters outside of the English alphabet will be limited, especially those with very few overlapping characters like Mandarin or Arabic. The whitelist must now be a set of all characters in all languages that we wish to support.
		</p>

		<p>
			Next, you must implement this filter programmatically. <a href="https://en.wikipedia.org/wiki/Regular_expression">Regular Expressions</a> are the tool for this job. Regular Expressions define a "pattern" that we can use for searching in strings. In particular, we can create a pattern that defines our whitelist characters and then detect if our untrusted strings contain only those characters. The Java <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html">regular expression API</a> includes everything we need and support for many languages. Explore the <code>java.util.regex</code> package for information on how we might do this. Once you have a basic understanding of pattern matching and character classes, come back here to start formulating our whitelist.
		</p>

		<p>
			Our whitelist will be a character class that matches only letters, numbers, underscores, and hyphens. Looking at <code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#ucc">java.util.regex.Pattern</a></code>, we can see that <code>\p{L}</code> matches all unicode letters. Similarly, <code>\p{Digit}</code> matches all digits. Our character class should then look something like <code>[\p{L}\p{Digit}_-]</code>. To match a string that contains at least one of any of those characters and no others, our regular expression becomes:
		</p>

		<pre><code>[\p{L}\p{Digit}_-]+</code></pre>

		<p>
			Now your task is to implement this filter using the Java regular expression API. The important API call will be <code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#matches-java.lang.String-java.lang.CharSequence-">Pattern.matches(regex, input)</a></code>. Devise a way to check the untrusted data against our regular expression and deny any username that does not match our whitelist. An appropriate response to an invalid username is to call <code>res.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid username characters");</code> in each <code>doGet</code> method.
		</p>

		<p>
			Shut down the server if it is running by typing <code>quit</code> in the command line interface and pressing enter. Implement your whitelist filter and test the exploits you created earlier. Ever time you change a source file, you must run the <code>make</code> command before running the server again. Run the server by executing the <code>run.sh</code> script after compiling with your new changes. Test the implementation You should find that any input not matching our whitelist will cause an error. Make sure to test good inputs to be sure the site still functions normally. Repeat this process until you are satisfied that the cross site scripting vulnerability is mitigated.
		</p>

		<p>
			Congratulations! You've mitigated the cross site scripting vulnerability in this exercise. Now you should go on to see how we deal with <a href="3.9.1_cross_site_request_forgery.html"> cross site request forgery</a> vulnerabilities.
		</p>

	</div>
</body>
</html>
